@using SupperSlonicWebSite.Models;

@model IList<TabWidgetModel>

<h1 class="first" id="description">DynamoDB</h1>
<p>My package provides functionality to deploy your tables on DynamoDB easily, to run different versions of tables simultaneously, to lock records in a table for isolated serious of operations.</p>
<p>You can find good code examples by downloading a provided demo package.</p>

<h1 id="versioning">Versioning</h1>
<p>When databases are maintained locally it is always very easy to make different versions of the same database running on different services for different environments: development, test or production environment.  Your software always knows the exact name of the table and it fields, the only thing you need to change is a connection string to switch between different services/environments.</p>
<p>The problem with <strong>DynamoDB</strong> is that your connection is always the same; you can’t change the server name. The only solution is to change the table name. But in this case, you need to recompile your code which is not very convenient.</p>
@Html.Partial("DownloadExampleWidget")
<p>My solution is to make the table name configurable and variable depending on which environment application is running in. For this purpose, I created three main classes:</p>
<ol>
    <li><a class="textLink" href="@Url.Action("AmazonContext", "AWS")"><strong>AmazonContext</strong> – An analog of a connection string to AWS</a>;</li>
    <li><strong>DynamodDBTable</strong> – An abstract class that represents a table in DynamoDB. This class knows the template name of a table, that varies depending on the environment;</li>
    <li><strong>BaseDAL</strong> – A class that manipulates AmazonContext and DynamoDBTable, providing all the required logic to make requests to a proper instance of the table.</li>
</ol>
<p>To make it more clear, here is an example:<br />
You have a table "PinkElephant". You create several instances of this table in DynamoDB:</p>
<ul>
    <li>PinkElephant.dev;</li>
    <li>PinkElephant.test;</li>
    <li>PinkElephant.production.</li>
</ul>
<p>When you run your application, you construct an AmazonContext object specifying, for instance, an environment name test. Then all the operations will be performed with a PinkElephant.test instance of a table.</p>

<h1 id="deployment">Deployment</h1>
<p>My java package contains a ready to use <strong>DeployDAL</strong> that allows you to create, delete DynamoDB tables on Amazon easily.<br />
In order to use this DAL your class should extend an abstract class <strong>DynamoDBSchema</strong>.</p>
<p>Example:</p>
<div class="demo">
DeployDAL dal = new DeployDAL(context, new PinkElephantTable(context));<br />
<br />	
if(!dal.tableExists())<br />
{<br />
<span style="padding-left:20px">dal.createTable();</span><br />
}<br />
else<br />
{<br />
<span style="padding-left:20px">System.out.println("Table already exists");</span><br />
}<br />
</div>

<h1 id="locking">Locking</h1>
<p>Sometimes you need to perform a serious of operations on <strong>DynamoDB tables</strong> or <strong>S3 files</strong> in an isolated and exclusive fashion, without interfering with anyone.<br />
Amazon doesn't have a built-in locking mechanism.  And you can't use the standard synchronization techniques provided by your programming language because your application can be run in very different environments.</p>

<p>So, how can it be done?</p>

<p>My java package provides a <strong>pessimistic lock functionality</strong> to work with AWS. This prevents data from being corrupted or invalidated when multiple users try to write to DynamoDB or S3.</p>
<p>There are two concepts at the heart of my locking mechanism:</p>
<ol>
    <li><strong>Pessimistic lock</strong>:<br />
        In pessimistic locking data is locked immediately when the lock is requested. This lock not only provides exclusivity to writes but also prevents reading of unfinished modifications.
    </li>
    <li><strong>Conditional update</strong>:<br />
        Amazon DynamoDB supports <a class="textLink" href=" http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithDDItems.html">conditional update operations</a>. It means that an operation will be completed successfully only if it satisfies the provided conditions.
    </li>
</ol>
<p>How it works:</p>
<p>First, you need to create a DynamoDB table that will only be used for locking purposes. Let’s call it a “LockTable”.</p>
<p>Then, use a conditional insert of a record into this “LockTable”. It means that you will only write a record into the table if it doesn't exist there. Otherwise, you should wait some time and try again.</p>
<p>Imagine that you have a table "PinkElephant", and before writing a record into it you want to read the data first and make some verification with your code. And while you are verifying the data no one is allowed to update this record.</p>
<p>This record has a field “Name” which is a unique identifier across the table. You can use this value as a key in your “LockTable”. You insert the record into you “LockTable” and perform the operations.</p>
<div class="demo" style="width:508px"><img src="~/Content/img/getLock.jpg" alt="getLock"/></div>
<p>If other users try to update this record they will see a record in the “LockTable” notifying them that someone is already working with it and they have to wait.</p>
<div class="demo" style="float:left;width:281px;margin-top:0px"><img src="~/Content/img/lockInProgress.jpg" alt="getLock"/></div>
<p>After you have finished, you delete the record.</p>
<p>The same approach applies to <strong>modifying files in S3</strong>. You can use a file name as a key in your “LockTable”.</p>
<p>What is good about this idea is that everything is stored on AWS, you don't have to have an additional local Database.</p>
<p>But you should be careful with using the same locking table for different purposes as the throughput can be significantly increased.</p>
<p>This package has a built-in DAL for managing lock-records: <strong>LockDAL</strong>. And a built-in lock-table: <strong>SimpleLockTable</strong>,  but you can use your own tables, they just need to extend the <strong>DynamoDBTable class</strong> and implement an <strong>interface ILockTable</strong>.</p>
<p>Please find the example code above.</p>
 @foreach (TabWidgetModel tabWidget in this.Model)
    { @Html.Partial("TabWidget", tabWidget) }
